# -*- coding: utf-8 -*-
"""Final-version_ITEC5205_Project-Sale-Forcast.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kRfJODkDRGgRI7-_hJ35c_J6VK-0WHGw
"""

#Installing Facebook prophet packages
!pip install fbprophet

pip install pystan #Installing prophet package

#Granting access to Google Colab to upload dataset 
#Mouting the drive and Google drive
from google.colab import drive
drive.mount('/content/drive')

path = 'drive/My Drive/Colab Notebooks/Walmart.csv.xls' #Reading data to the file path

#Importing Python libraries essentials for this code
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.simplefilter ('ignore')
from fbprophet import Prophet
from sklearn.model_selection import train_test_split
from sklearn.svm import SVR
from sklearn.metrics import mean_absolute_error
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_percentage_error
from sklearn.metrics import mean_squared_error

#Reading in the file

df = pd.read_csv (path)

df.head()

df.describe ()

"""Data exploration to detect interesting fact about the dataset and preprocessing"""

df.dtypes

#Duplicate data type
df_LR = df.copy()
df_SVR = df.copy()
df_PR = df.copy()

df.info()

import plotly.express as px
fig = px.imshow(df.corr())
fig.show()

#Box plot for the weekly sales

fig = px.box(df['Weekly_Sales'], points="all")
fig.show()

fig = px.box(df, x="Holiday_Flag", y="Weekly_Sales") #Box plot showing weekly sales and holiday
fig.show()

fig = px.scatter(df, x = "Date", y = "Weekly_Sales", color='Temperature') #Sales record corresponding to temperature
fig.show()

#Record of sales across the stores

fig = px.line(df, x='Store', y='Weekly_Sales', color='Date', markers=True)
#px.title ('Weekly sales record across the stores')
fig.show()

sns.scatterplot(y= df['Weekly_Sales'], x = df['Holiday_Flag'])
plt.figure(figsize=(10,20))

sns.scatterplot(y = df['Weekly_Sales'], x = df['Temperature'])

sns.scatterplot(y = df['Weekly_Sales'], x = df['Fuel_Price'])

sns.scatterplot(y = df['Weekly_Sales'], x = df['CPI'])

sns.scatterplot(y = df['Weekly_Sales'], x = df['Unemployment'])

sns.pairplot(df)

# Reformatting the datatype to datetime format
df['Date'] = pd.to_datetime(df['Date'])

df['Month'] = df['Date'].dt.month
df['Year'] = df['Date'].dt.year
df['Day'] = df['Date'].dt.day

df['ds'] = pd.DatetimeIndex((df['Year'].apply(str) + '-' + df['Month'].apply(str) + '-' + df['Day'].apply(str))) #Concatenating the dates

df.head()

sm_df = df.groupby('Month')['Weekly_Sales'].sum() #visualize the sales performance of each store per month

sm_df.tail()

plt.figure(figsize = (15,8))
sns.scatterplot(y=df['Weekly_Sales'], x=df['Date'], hue = df['Holiday_Flag'])

df.head()

df.pivot_table("Weekly_Sales", index="Store", columns="Year").plot(figsize=(14,6)) 
plt.title("Sales trend between the stores between 2010 and 2012")
#plt.ylabel("Sales")
plt.xlabel("Store ID")

df_PR.tail()

df.dtypes

"""### **Sales predictive model**"""

df.drop(columns = ['Fuel_Price', 'CPI', 'Month', 'Day', 'Year','Date'])

df = df.loc[df.Store == 1, :]

df2 = df.reset_index()[['ds','Weekly_Sales', 'Holiday_Flag','Temperature','Unemployment']].rename({'ds':'ds', 'Weekly_Sales':'y'}, axis= 'columns')

m = Prophet(interval_width = 0.95) #Fitting our model

m.add_country_holidays(country_name='US')


model = m.fit(df2)

future = m.make_future_dataframe(periods=50)

future.tail()


future

forecast = model.predict(future)

fig1 = m.plot(forecast)

from fbprophet.plot import plot_plotly 
import plotly.offline as py

fig = plot_plotly(m, forecast)

py.iplot(fig)

pd.concat([df2.set_index('ds')['y'], forecast.set_index('ds')['yhat']], axis=1).plot()

#Cross validate
from fbprophet.diagnostics import cross_validation
df_cv = cross_validation(m, initial='50 days', horizon = '30 days')


# Validating the result of the test
from fbprophet.diagnostics import performance_metrics
df_p = performance_metrics(df_cv)
df_p.head()
#df_p.mean()

"""Finetune parameters iteratively"""

import itertools #Fine tuning

param_grid = {  
    'changepoint_prior_scale': [0.001, 0.01, 0.1, 0.5],
    'seasonality_prior_scale': [0.01, 0.1, 1.0, 10.0],   
}

# Generate all combinations of parameters
all_params = [dict(zip(param_grid.keys(), v)) for v in itertools.product(*param_grid.values())]
maes = []  # Store the MAE for each params here
mapes = [] # Store the MAPE for each params here

# Use cross validation to evaluate all parameters
for params in all_params:
    m = Prophet(**params).fit(df2)  # Fit model with given params
    df_cv = cross_validation(m, horizon='90 days', parallel="processes")
    df_p = performance_metrics(df_cv, rolling_window=1)
    maes.append(df_p['mae'].values[0])
    mapes.append(df_p['mape'].values[0])

# Find the best parameters
tuning_results = pd.DataFrame(all_params)
tuning_results['mae'] = maes
tuning_results['mape'] = mapes



best_params = all_params[np.argmin(mapes)]
print(best_params)

#Fine-tuing parameter

m = Prophet(interval_width=0.95, weekly_seasonality=True, changepoint_prior_scale=0.01,
            changepoint_range=0.8,
            seasonality_prior_scale=0.5,
            holidays_prior_scale=1.0,
            yearly_seasonality=20,
            seasonality_mode='additive')

#seasonality_prior_scale= best_params['seasonality prior scale'])
m.add_country_holidays(country_name='US')
model = m.fit(df2)

future = m.make_future_dataframe (periods=30)

fig = m.plot_components(forecast)

fig = plot_plotly(m, forecast)

py.iplot(fig)

pd.concat([df2.set_index('ds')['y'], forecast.set_index('ds')['yhat']], axis=1).plot()

df_cv = cross_validation(m, initial='28 days', horizon = '20 days')


# Validating the result of the test

df_p = performance_metrics(df_cv)
df_p.head()
#df_p.mean()

df_p.mean()

copy_df.query('unemp != unemp')

"""***Break point for this function***

Linear regression Model
"""

x = df_LR.drop(columns = ['Weekly_Sales', 'Fuel_Price', 'CPI', 'Date'], axis = 1).values
y = df_LR['Weekly_Sales'].values

# importing train_test_split from sklearn
from sklearn.model_selection import train_test_split
# splitting the data
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 42)

# importing module
from sklearn.linear_model import LinearRegression
# creating an object of LinearRegression class
LR = LinearRegression()

# fitting the training data
LR.fit(x,y)

y_prediction =  LR.predict(x_test)
y_prediction

#Evaluate

from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error
# predicting the accuracy score
score=r2_score(y_test,y_prediction)
print('r square socre is',score)
print('mean_sqrd_error is==', mean_squared_error(y_test,y_prediction))
print('root_mean_squared error of is==', np.sqrt(mean_squared_error(y_test,y_prediction)))
print('mean_absolute_percentage_square_error is==', mean_absolute_percentage_error(y_test,y_prediction))



"""Blank---

Support Vector Regression Model
"""

df_SVR

x = df_SVR.drop(columns = ['Weekly_Sales', 'Fuel_Price', 'CPI', 'Date'], axis = 1).values
y = df_SVR['Weekly_Sales'].values

from sklearn.svm import SVR
svr = SVR().fit(x, y)
yfit = svr.predict(x)
regressor = SVR(kernel='rbf')
regressor.fit(x,y)

print("MSE:", mean_squared_error(y, yfit))
print("MAPE:", mean_absolute_percentage_error (y, yfit))
print("MAE:", mean_absolute_error (y, yfit))

